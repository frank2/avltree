<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AVL Tree: avltree::AVLTreeBase&lt; Key, Value, KeyOfValue, KeyCompare &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AVL Tree<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">An AVL tree implementation for C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>avltree</b></li><li class="navelem"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html">AVLTreeBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classavltree_1_1_a_v_l_tree_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">avltree::AVLTreeBase&lt; Key, Value, KeyOfValue, KeyCompare &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The base implementation of an AVL tree.  
 <a href="classavltree_1_1_a_v_l_tree_base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for avltree::AVLTreeBase&lt; Key, Value, KeyOfValue, KeyCompare &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classavltree_1_1_a_v_l_tree_base.png" usemap="#avltree::AVLTreeBase_3C_20Key_2C_20Value_2C_20KeyOfValue_2C_20KeyCompare_20_3E_map" alt=""/>
  <map id="avltree::AVLTreeBase_3C_20Key_2C_20Value_2C_20KeyOfValue_2C_20KeyCompare_20_3E_map" name="avltree::AVLTreeBase_3C_20Key_2C_20Value_2C_20KeyOfValue_2C_20KeyCompare_20_3E_map">
<area href="classavltree_1_1_a_v_l_map.html" title="A mapping implementation based on an AVL tree." alt="avltree::AVLMap&lt; Key, Value, KeyCompare &gt;" shape="rect" coords="0,56,384,80"/>
<area href="classavltree_1_1_a_v_l_tree.html" title="A simplified AVLTree interface." alt="avltree::AVLTree&lt; Key, KeyCompare &gt;" shape="rect" coords="394,56,778,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__inorder__iterator.html">const_inorder_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that performs an in-order traversal on the tree, returning const nodes.  <a href="classavltree_1_1_a_v_l_tree_base_1_1const__inorder__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__postorder__iterator.html">const_postorder_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that performs a post-order traversal on the tree, returning const nodes.  <a href="classavltree_1_1_a_v_l_tree_base_1_1const__postorder__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__preorder__iterator.html">const_preorder_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that performs a pre-order traversal on the tree, returning const nodes.  <a href="classavltree_1_1_a_v_l_tree_base_1_1const__preorder__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_value_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that yields const value objects instead of nodes.  <a href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1inorder__iterator.html">inorder_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that performs an in-order traversal on the tree.  <a href="classavltree_1_1_a_v_l_tree_base_1_1inorder__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1inorder__iterator__base.html">inorder_iterator_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base iterator for performing an in-order traversal.  <a href="classavltree_1_1_a_v_l_tree_base_1_1inorder__iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node object for an AVL tree.  <a href="classavltree_1_1_a_v_l_tree_base_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1postorder__iterator.html">postorder_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that performs a post-order traversal on the tree.  <a href="classavltree_1_1_a_v_l_tree_base_1_1postorder__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1postorder__iterator__base.html">postorder_iterator_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base iterator for performing a post-order traversal.  <a href="classavltree_1_1_a_v_l_tree_base_1_1postorder__iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1preorder__iterator.html">preorder_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that performs a pre-order traversal on the tree.  <a href="classavltree_1_1_a_v_l_tree_base_1_1preorder__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1preorder__iterator__base.html">preorder_iterator_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base iterator for performing a pre-order traversal.  <a href="classavltree_1_1_a_v_l_tree_base_1_1preorder__iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">value_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that yields value objects instead of nodes.  <a href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a60cee3e4588c71f2fd2cfb9f8c3a1ff8"><td class="memItemLeft" align="right" valign="top"><a id="a60cee3e4588c71f2fd2cfb9f8c3a1ff8" name="a60cee3e4588c71f2fd2cfb9f8c3a1ff8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KeyType</b> = typename Key</td></tr>
<tr class="separator:a60cee3e4588c71f2fd2cfb9f8c3a1ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac153c7269e61b2e542f2d41fa1767fa3"><td class="memItemLeft" align="right" valign="top"><a id="ac153c7269e61b2e542f2d41fa1767fa3" name="ac153c7269e61b2e542f2d41fa1767fa3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ValueType</b> = typename Value</td></tr>
<tr class="separator:ac153c7269e61b2e542f2d41fa1767fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6137881a785d0833bcd1dcfd36581c6"><td class="memItemLeft" align="right" valign="top"><a id="ac6137881a785d0833bcd1dcfd36581c6" name="ac6137881a785d0833bcd1dcfd36581c6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SharedNode</b> = std::shared_ptr&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1_node.html">Node</a> &gt;</td></tr>
<tr class="separator:ac6137881a785d0833bcd1dcfd36581c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0e56bd5414f79facdabb5cac62528e"><td class="memItemLeft" align="right" valign="top"><a id="a1b0e56bd5414f79facdabb5cac62528e" name="a1b0e56bd5414f79facdabb5cac62528e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConstSharedNode</b> = std::shared_ptr&lt; const <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1_node.html">Node</a> &gt;</td></tr>
<tr class="separator:a1b0e56bd5414f79facdabb5cac62528e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8bffd198d9cdaf02577d3f835431cb"><td class="memItemLeft" align="right" valign="top"><a id="a6a8bffd198d9cdaf02577d3f835431cb" name="a6a8bffd198d9cdaf02577d3f835431cb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1postorder__iterator.html">postorder_iterator</a> &gt;</td></tr>
<tr class="separator:a6a8bffd198d9cdaf02577d3f835431cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff21721c836c7b61cea3c7f8bb82249"><td class="memItemLeft" align="right" valign="top"><a id="a6ff21721c836c7b61cea3c7f8bb82249" name="a6ff21721c836c7b61cea3c7f8bb82249"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__postorder__iterator.html">const_postorder_iterator</a> &gt;</td></tr>
<tr class="separator:a6ff21721c836c7b61cea3c7f8bb82249"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43c180225121f2c9f5287a5d09a032dd"><td class="memItemLeft" align="right" valign="top"><a id="a43c180225121f2c9f5287a5d09a032dd" name="a43c180225121f2c9f5287a5d09a032dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AVLTreeBase</b> (std::vector&lt; Value &gt; &amp;nodes)</td></tr>
<tr class="separator:a43c180225121f2c9f5287a5d09a032dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d524167975b08dcdafef4389390038"><td class="memItemLeft" align="right" valign="top"><a id="a15d524167975b08dcdafef4389390038" name="a15d524167975b08dcdafef4389390038"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AVLTreeBase</b> (const <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">AVLTreeBase</a> &amp;other)</td></tr>
<tr class="separator:a15d524167975b08dcdafef4389390038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025ef378547bb67d1d4e256db4e34c27"><td class="memItemLeft" align="right" valign="top"><a id="a025ef378547bb67d1d4e256db4e34c27" name="a025ef378547bb67d1d4e256db4e34c27"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1inorder__iterator.html">inorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin_inorder</b> ()</td></tr>
<tr class="memdesc:a025ef378547bb67d1d4e256db4e34c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator at the beginning of an in-order traversal. <br /></td></tr>
<tr class="separator:a025ef378547bb67d1d4e256db4e34c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ff056a64a16224acbc5700646acbc8"><td class="memItemLeft" align="right" valign="top"><a id="a23ff056a64a16224acbc5700646acbc8" name="a23ff056a64a16224acbc5700646acbc8"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1inorder__iterator.html">inorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_inorder</b> ()</td></tr>
<tr class="memdesc:a23ff056a64a16224acbc5700646acbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator at the end of an in-order traversal. <br /></td></tr>
<tr class="separator:a23ff056a64a16224acbc5700646acbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e896e6a6fe83c061acef6d76fbfb379"><td class="memItemLeft" align="right" valign="top"><a id="a0e896e6a6fe83c061acef6d76fbfb379" name="a0e896e6a6fe83c061acef6d76fbfb379"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__inorder__iterator.html">const_inorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_inorder</b> () const</td></tr>
<tr class="memdesc:a0e896e6a6fe83c061acef6d76fbfb379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator at the beginning of an in-order traversal. <br /></td></tr>
<tr class="separator:a0e896e6a6fe83c061acef6d76fbfb379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0344b9c6327ed8b41d81509d10ca6b5"><td class="memItemLeft" align="right" valign="top"><a id="ac0344b9c6327ed8b41d81509d10ca6b5" name="ac0344b9c6327ed8b41d81509d10ca6b5"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__inorder__iterator.html">const_inorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend_inorder</b> () const</td></tr>
<tr class="memdesc:ac0344b9c6327ed8b41d81509d10ca6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator at the end of an in-order traversal. <br /></td></tr>
<tr class="separator:ac0344b9c6327ed8b41d81509d10ca6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafea3d86d69bbc7758cb328e024a9a0a"><td class="memItemLeft" align="right" valign="top"><a id="aafea3d86d69bbc7758cb328e024a9a0a" name="aafea3d86d69bbc7758cb328e024a9a0a"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1preorder__iterator.html">preorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin_preorder</b> ()</td></tr>
<tr class="memdesc:aafea3d86d69bbc7758cb328e024a9a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator at the beginning of a pre-order traversal. <br /></td></tr>
<tr class="separator:aafea3d86d69bbc7758cb328e024a9a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2462f5f0277a61d2eed752ab2442c44d"><td class="memItemLeft" align="right" valign="top"><a id="a2462f5f0277a61d2eed752ab2442c44d" name="a2462f5f0277a61d2eed752ab2442c44d"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1preorder__iterator.html">preorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_preorder</b> ()</td></tr>
<tr class="memdesc:a2462f5f0277a61d2eed752ab2442c44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator at the end of a pre-order traversal. <br /></td></tr>
<tr class="separator:a2462f5f0277a61d2eed752ab2442c44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fcf320e0f92f940e92fd071e6dce08"><td class="memItemLeft" align="right" valign="top"><a id="a97fcf320e0f92f940e92fd071e6dce08" name="a97fcf320e0f92f940e92fd071e6dce08"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__preorder__iterator.html">const_preorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_preorder</b> () const</td></tr>
<tr class="memdesc:a97fcf320e0f92f940e92fd071e6dce08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator at the beginning of a pre-order traversal. <br /></td></tr>
<tr class="separator:a97fcf320e0f92f940e92fd071e6dce08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6acef62e4ac9270201481473b656fa"><td class="memItemLeft" align="right" valign="top"><a id="a7c6acef62e4ac9270201481473b656fa" name="a7c6acef62e4ac9270201481473b656fa"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__preorder__iterator.html">const_preorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend_preorder</b> () const</td></tr>
<tr class="memdesc:a7c6acef62e4ac9270201481473b656fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator at the end of a pre-order traversal. <br /></td></tr>
<tr class="separator:a7c6acef62e4ac9270201481473b656fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfbd7699961a27c9a47cb5fd4e4fdf8"><td class="memItemLeft" align="right" valign="top"><a id="abcfbd7699961a27c9a47cb5fd4e4fdf8" name="abcfbd7699961a27c9a47cb5fd4e4fdf8"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1postorder__iterator.html">postorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin_postorder</b> ()</td></tr>
<tr class="memdesc:abcfbd7699961a27c9a47cb5fd4e4fdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator at the beginning of a post-order traversal. <br /></td></tr>
<tr class="separator:abcfbd7699961a27c9a47cb5fd4e4fdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e00fa6086173e1cd8c5cc341706c69c"><td class="memItemLeft" align="right" valign="top"><a id="a7e00fa6086173e1cd8c5cc341706c69c" name="a7e00fa6086173e1cd8c5cc341706c69c"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1postorder__iterator.html">postorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_postorder</b> ()</td></tr>
<tr class="memdesc:a7e00fa6086173e1cd8c5cc341706c69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator at the end of a post-order traversal. <br /></td></tr>
<tr class="separator:a7e00fa6086173e1cd8c5cc341706c69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ae34d49551207a53eaf500ee98fbcc"><td class="memItemLeft" align="right" valign="top"><a id="a98ae34d49551207a53eaf500ee98fbcc" name="a98ae34d49551207a53eaf500ee98fbcc"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__postorder__iterator.html">const_postorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_postorder</b> () const</td></tr>
<tr class="memdesc:a98ae34d49551207a53eaf500ee98fbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator at the beginning of a post-order traversal. <br /></td></tr>
<tr class="separator:a98ae34d49551207a53eaf500ee98fbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d69b480570b31615b114b166488cfaf"><td class="memItemLeft" align="right" valign="top"><a id="a8d69b480570b31615b114b166488cfaf" name="a8d69b480570b31615b114b166488cfaf"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__postorder__iterator.html">const_postorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend_postorder</b> () const</td></tr>
<tr class="memdesc:a8d69b480570b31615b114b166488cfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator at the end of a post-order traversal. <br /></td></tr>
<tr class="separator:a8d69b480570b31615b114b166488cfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad6066c26d6992d5b869d93b7e2fcd3"><td class="memItemLeft" align="right" valign="top"><a id="acad6066c26d6992d5b869d93b7e2fcd3" name="acad6066c26d6992d5b869d93b7e2fcd3"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1inorder__iterator.html">inorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>begin_values_inorder</b> ()</td></tr>
<tr class="memdesc:acad6066c26d6992d5b869d93b7e2fcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value iterator at the beginning of an in-order traversal. <br /></td></tr>
<tr class="separator:acad6066c26d6992d5b869d93b7e2fcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed129a2e9d9212ec97589e4717387f18"><td class="memItemLeft" align="right" valign="top"><a id="aed129a2e9d9212ec97589e4717387f18" name="aed129a2e9d9212ec97589e4717387f18"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1inorder__iterator.html">inorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>end_values_inorder</b> ()</td></tr>
<tr class="memdesc:aed129a2e9d9212ec97589e4717387f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value iterator at the end of an in-order traversal. <br /></td></tr>
<tr class="separator:aed129a2e9d9212ec97589e4717387f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e1d40d90ace5fe772931a4ff19ea3b"><td class="memItemLeft" align="right" valign="top"><a id="ad6e1d40d90ace5fe772931a4ff19ea3b" name="ad6e1d40d90ace5fe772931a4ff19ea3b"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__inorder__iterator.html">const_inorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_values_inorder</b> ()</td></tr>
<tr class="memdesc:ad6e1d40d90ace5fe772931a4ff19ea3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const value iterator at the beginning of an in-order traversal. <br /></td></tr>
<tr class="separator:ad6e1d40d90ace5fe772931a4ff19ea3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce224acd887e48bf99ba332e7de7d24"><td class="memItemLeft" align="right" valign="top"><a id="a7ce224acd887e48bf99ba332e7de7d24" name="a7ce224acd887e48bf99ba332e7de7d24"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__inorder__iterator.html">const_inorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cend_values_inorder</b> ()</td></tr>
<tr class="memdesc:a7ce224acd887e48bf99ba332e7de7d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const value iterator at the end of an in-order traversal. <br /></td></tr>
<tr class="separator:a7ce224acd887e48bf99ba332e7de7d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97266af8b9949ca5d1251101679184b3"><td class="memItemLeft" align="right" valign="top"><a id="a97266af8b9949ca5d1251101679184b3" name="a97266af8b9949ca5d1251101679184b3"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1preorder__iterator.html">preorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>begin_values_preorder</b> ()</td></tr>
<tr class="memdesc:a97266af8b9949ca5d1251101679184b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value iterator at the beginning of a pre-order traversal. <br /></td></tr>
<tr class="separator:a97266af8b9949ca5d1251101679184b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9642bc5ebb66b668f2f353fde3b7c3fd"><td class="memItemLeft" align="right" valign="top"><a id="a9642bc5ebb66b668f2f353fde3b7c3fd" name="a9642bc5ebb66b668f2f353fde3b7c3fd"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1preorder__iterator.html">preorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>end_values_preorder</b> ()</td></tr>
<tr class="memdesc:a9642bc5ebb66b668f2f353fde3b7c3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value iterator at the end of a pre-order traversal. <br /></td></tr>
<tr class="separator:a9642bc5ebb66b668f2f353fde3b7c3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae8358d7f63ef1df085a57080166d26"><td class="memItemLeft" align="right" valign="top"><a id="acae8358d7f63ef1df085a57080166d26" name="acae8358d7f63ef1df085a57080166d26"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__preorder__iterator.html">const_preorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_values_preorder</b> ()</td></tr>
<tr class="memdesc:acae8358d7f63ef1df085a57080166d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const value iterator at the beginning of a pre-order traversal. <br /></td></tr>
<tr class="separator:acae8358d7f63ef1df085a57080166d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeab8312bfa4ac6166da0a1e057b96ca"><td class="memItemLeft" align="right" valign="top"><a id="adeab8312bfa4ac6166da0a1e057b96ca" name="adeab8312bfa4ac6166da0a1e057b96ca"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__preorder__iterator.html">const_preorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cend_values_preorder</b> ()</td></tr>
<tr class="memdesc:adeab8312bfa4ac6166da0a1e057b96ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const value iterator at the end of a pre-order traversal. <br /></td></tr>
<tr class="separator:adeab8312bfa4ac6166da0a1e057b96ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa1c826d826ca319f726706ef60be2a"><td class="memItemLeft" align="right" valign="top"><a id="a6aa1c826d826ca319f726706ef60be2a" name="a6aa1c826d826ca319f726706ef60be2a"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1postorder__iterator.html">postorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>begin_values_postorder</b> ()</td></tr>
<tr class="memdesc:a6aa1c826d826ca319f726706ef60be2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value iterator at the beginning of a post-order traversal. <br /></td></tr>
<tr class="separator:a6aa1c826d826ca319f726706ef60be2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da040ee4e15c8ec902a8f27780b31ce"><td class="memItemLeft" align="right" valign="top"><a id="a2da040ee4e15c8ec902a8f27780b31ce" name="a2da040ee4e15c8ec902a8f27780b31ce"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1postorder__iterator.html">postorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>end_values_postorder</b> ()</td></tr>
<tr class="memdesc:a2da040ee4e15c8ec902a8f27780b31ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value iterator at the end of a post-order traversal. <br /></td></tr>
<tr class="separator:a2da040ee4e15c8ec902a8f27780b31ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94436d1e955d14b158a77ff69f8d8f33"><td class="memItemLeft" align="right" valign="top"><a id="a94436d1e955d14b158a77ff69f8d8f33" name="a94436d1e955d14b158a77ff69f8d8f33"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__postorder__iterator.html">const_postorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_values_postorder</b> ()</td></tr>
<tr class="memdesc:a94436d1e955d14b158a77ff69f8d8f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const value iterator at the beginning of a post-order traversal. <br /></td></tr>
<tr class="separator:a94436d1e955d14b158a77ff69f8d8f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19be4f1bf700c6452fd9587de460ca15"><td class="memItemLeft" align="right" valign="top"><a id="a19be4f1bf700c6452fd9587de460ca15" name="a19be4f1bf700c6452fd9587de460ca15"></a>
<a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_value_iterator</a>&lt; <a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__postorder__iterator.html">const_postorder_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cend_values_postorder</b> ()</td></tr>
<tr class="memdesc:a19be4f1bf700c6452fd9587de460ca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const value iterator at the end of a post-order traversal. <br /></td></tr>
<tr class="separator:a19be4f1bf700c6452fd9587de460ca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0054359ae962c3551d17b5b2c799e10d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a0054359ae962c3551d17b5b2c799e10d">begin</a> ()</td></tr>
<tr class="memdesc:a0054359ae962c3551d17b5b2c799e10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a default iterator to the beginning of the tree.  <a href="classavltree_1_1_a_v_l_tree_base.html#a0054359ae962c3551d17b5b2c799e10d">More...</a><br /></td></tr>
<tr class="separator:a0054359ae962c3551d17b5b2c799e10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7795faf04ec3b8187b5e5f05013b6e1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a7795faf04ec3b8187b5e5f05013b6e1e">end</a> ()</td></tr>
<tr class="memdesc:a7795faf04ec3b8187b5e5f05013b6e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a default iterator to the end of the tree.  <a href="classavltree_1_1_a_v_l_tree_base.html#a7795faf04ec3b8187b5e5f05013b6e1e">More...</a><br /></td></tr>
<tr class="separator:a7795faf04ec3b8187b5e5f05013b6e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e89d00f5b4a83f4e3fe5f0ca35499dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a7e89d00f5b4a83f4e3fe5f0ca35499dd">cbegin</a> () const</td></tr>
<tr class="memdesc:a7e89d00f5b4a83f4e3fe5f0ca35499dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a default const iterator to the beginning of the tree.  <a href="classavltree_1_1_a_v_l_tree_base.html#a7e89d00f5b4a83f4e3fe5f0ca35499dd">More...</a><br /></td></tr>
<tr class="separator:a7e89d00f5b4a83f4e3fe5f0ca35499dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7feab33db9c3774e683f826c415b3d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#ae7feab33db9c3774e683f826c415b3d0">cend</a> () const</td></tr>
<tr class="memdesc:ae7feab33db9c3774e683f826c415b3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a default const iterator to the end of the tree.  <a href="classavltree_1_1_a_v_l_tree_base.html#ae7feab33db9c3774e683f826c415b3d0">More...</a><br /></td></tr>
<tr class="separator:ae7feab33db9c3774e683f826c415b3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2d89eb2a723c38c7ff3c615eb57aae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a2c2d89eb2a723c38c7ff3c615eb57aae">is_empty</a> () const</td></tr>
<tr class="memdesc:a2c2d89eb2a723c38c7ff3c615eb57aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the tree is empty.  <a href="classavltree_1_1_a_v_l_tree_base.html#a2c2d89eb2a723c38c7ff3c615eb57aae">More...</a><br /></td></tr>
<tr class="separator:a2c2d89eb2a723c38c7ff3c615eb57aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6e7752909675f53a79ebfab4f4d8ec"><td class="memItemLeft" align="right" valign="top"><a id="a3f6e7752909675f53a79ebfab4f4d8ec" name="a3f6e7752909675f53a79ebfab4f4d8ec"></a>
SharedNode&#160;</td><td class="memItemRight" valign="bottom"><b>root</b> ()</td></tr>
<tr class="memdesc:a3f6e7752909675f53a79ebfab4f4d8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the root node of this tree. <br /></td></tr>
<tr class="separator:a3f6e7752909675f53a79ebfab4f4d8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136c73cedc47e2d9a9e16ab498712590"><td class="memItemLeft" align="right" valign="top"><a id="a136c73cedc47e2d9a9e16ab498712590" name="a136c73cedc47e2d9a9e16ab498712590"></a>
ConstSharedNode&#160;</td><td class="memItemRight" valign="bottom"><b>root</b> () const</td></tr>
<tr class="memdesc:a136c73cedc47e2d9a9e16ab498712590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the const root node of this tree. <br /></td></tr>
<tr class="separator:a136c73cedc47e2d9a9e16ab498712590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7991228b296d8694d24c205debbfc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a4b7991228b296d8694d24c205debbfc4">contains</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a4b7991228b296d8694d24c205debbfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given key exists in the tree.  <a href="classavltree_1_1_a_v_l_tree_base.html#a4b7991228b296d8694d24c205debbfc4">More...</a><br /></td></tr>
<tr class="separator:a4b7991228b296d8694d24c205debbfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4282cd8896a0f9aaa3cc125062255494"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; ConstSharedNode, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a4282cd8896a0f9aaa3cc125062255494">search</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a4282cd8896a0f9aaa3cc125062255494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the tree for the given key, returning const nodes.  <a href="classavltree_1_1_a_v_l_tree_base.html#a4282cd8896a0f9aaa3cc125062255494">More...</a><br /></td></tr>
<tr class="separator:a4282cd8896a0f9aaa3cc125062255494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a4af9ed9fe2b84b4dfa20dbd9eb72f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; SharedNode, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a42a4af9ed9fe2b84b4dfa20dbd9eb72f">search</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a42a4af9ed9fe2b84b4dfa20dbd9eb72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the tree for the given key.  <a href="classavltree_1_1_a_v_l_tree_base.html#a42a4af9ed9fe2b84b4dfa20dbd9eb72f">More...</a><br /></td></tr>
<tr class="separator:a42a4af9ed9fe2b84b4dfa20dbd9eb72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa48749a74d07d1b9bd5aca39a7371a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; SharedNode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a1aa48749a74d07d1b9bd5aca39a7371a">find</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a1aa48749a74d07d1b9bd5aca39a7371a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to find the node corresponding to the given key in this tree.  <a href="classavltree_1_1_a_v_l_tree_base.html#a1aa48749a74d07d1b9bd5aca39a7371a">More...</a><br /></td></tr>
<tr class="separator:a1aa48749a74d07d1b9bd5aca39a7371a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213781a9c66c415c28de0509259c533d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; ConstSharedNode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a213781a9c66c415c28de0509259c533d">find</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a213781a9c66c415c28de0509259c533d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to find the const node corresponding to the given key in this tree.  <a href="classavltree_1_1_a_v_l_tree_base.html#a213781a9c66c415c28de0509259c533d">More...</a><br /></td></tr>
<tr class="separator:a213781a9c66c415c28de0509259c533d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e5c416fe580918417ccdbc54754c4a"><td class="memItemLeft" align="right" valign="top">SharedNode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a26e5c416fe580918417ccdbc54754c4a">get</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a26e5c416fe580918417ccdbc54754c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to get the node with the given key in the tree, throwing an exception if it fails.  <a href="classavltree_1_1_a_v_l_tree_base.html#a26e5c416fe580918417ccdbc54754c4a">More...</a><br /></td></tr>
<tr class="separator:a26e5c416fe580918417ccdbc54754c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29f033cf7fa7a6737a3728bec50aab9"><td class="memItemLeft" align="right" valign="top">ConstSharedNode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#ae29f033cf7fa7a6737a3728bec50aab9">get</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:ae29f033cf7fa7a6737a3728bec50aab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to get the const node with the given key in the tree, throwing an exception if it fails.  <a href="classavltree_1_1_a_v_l_tree_base.html#ae29f033cf7fa7a6737a3728bec50aab9">More...</a><br /></td></tr>
<tr class="separator:ae29f033cf7fa7a6737a3728bec50aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967cd2e0fe0dfe8b9edfff94d69697e7"><td class="memItemLeft" align="right" valign="top">SharedNode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a967cd2e0fe0dfe8b9edfff94d69697e7">insert</a> (const Value &amp;value)</td></tr>
<tr class="memdesc:a967cd2e0fe0dfe8b9edfff94d69697e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given value into the tree.  <a href="classavltree_1_1_a_v_l_tree_base.html#a967cd2e0fe0dfe8b9edfff94d69697e7">More...</a><br /></td></tr>
<tr class="separator:a967cd2e0fe0dfe8b9edfff94d69697e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccf63f9f9fd8b3e77644eac25378428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a8ccf63f9f9fd8b3e77644eac25378428">remove</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a8ccf63f9f9fd8b3e77644eac25378428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node with the given key from the tree.  <a href="classavltree_1_1_a_v_l_tree_base.html#a8ccf63f9f9fd8b3e77644eac25378428">More...</a><br /></td></tr>
<tr class="separator:a8ccf63f9f9fd8b3e77644eac25378428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562a02962c9d2dee95b058bfa1f33bab"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a562a02962c9d2dee95b058bfa1f33bab">to_vec</a> () const</td></tr>
<tr class="memdesc:a562a02962c9d2dee95b058bfa1f33bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this tree into a vector.  <a href="classavltree_1_1_a_v_l_tree_base.html#a562a02962c9d2dee95b058bfa1f33bab">More...</a><br /></td></tr>
<tr class="separator:a562a02962c9d2dee95b058bfa1f33bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11592fa1d5fce21d5f9378d774963c0c"><td class="memItemLeft" align="right" valign="top"><a id="a11592fa1d5fce21d5f9378d774963c0c" name="a11592fa1d5fce21d5f9378d774963c0c"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:a11592fa1d5fce21d5f9378d774963c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in this tree. <br /></td></tr>
<tr class="separator:a11592fa1d5fce21d5f9378d774963c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11302b2e4ab3f3a97a93a698ba1b4a67"><td class="memItemLeft" align="right" valign="top"><a id="a11302b2e4ab3f3a97a93a698ba1b4a67" name="a11302b2e4ab3f3a97a93a698ba1b4a67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy</b> ()</td></tr>
<tr class="memdesc:a11302b2e4ab3f3a97a93a698ba1b4a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy this tree. <br /></td></tr>
<tr class="separator:a11302b2e4ab3f3a97a93a698ba1b4a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33e8ed78f5a990e73a4896446d9992b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#ab33e8ed78f5a990e73a4896446d9992b">copy</a> (const <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">AVLTreeBase</a> &amp;other)</td></tr>
<tr class="memdesc:ab33e8ed78f5a990e73a4896446d9992b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the given tree into this tree.  <a href="classavltree_1_1_a_v_l_tree_base.html#ab33e8ed78f5a990e73a4896446d9992b">More...</a><br /></td></tr>
<tr class="separator:ab33e8ed78f5a990e73a4896446d9992b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a69c625f8cea8607f7638789f0273b8b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a69c625f8cea8607f7638789f0273b8b2">set_right_child</a> (SharedNode target, SharedNode child)</td></tr>
<tr class="memdesc:a69c625f8cea8607f7638789f0273b8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the right child of the given node.  <a href="classavltree_1_1_a_v_l_tree_base.html#a69c625f8cea8607f7638789f0273b8b2">More...</a><br /></td></tr>
<tr class="separator:a69c625f8cea8607f7638789f0273b8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f807cea16eccdc3351e0681b8ecd37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a13f807cea16eccdc3351e0681b8ecd37">set_left_child</a> (SharedNode target, SharedNode child)</td></tr>
<tr class="memdesc:a13f807cea16eccdc3351e0681b8ecd37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the left child of the given node.  <a href="classavltree_1_1_a_v_l_tree_base.html#a13f807cea16eccdc3351e0681b8ecd37">More...</a><br /></td></tr>
<tr class="separator:a13f807cea16eccdc3351e0681b8ecd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabaa07e25f87d547a0fb3837487ac52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#acabaa07e25f87d547a0fb3837487ac52">set_parent</a> (SharedNode target, SharedNode parent)</td></tr>
<tr class="memdesc:acabaa07e25f87d547a0fb3837487ac52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the parent of the given node.  <a href="classavltree_1_1_a_v_l_tree_base.html#acabaa07e25f87d547a0fb3837487ac52">More...</a><br /></td></tr>
<tr class="separator:acabaa07e25f87d547a0fb3837487ac52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67872d92abf1fb90bd9e49214358e474"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a67872d92abf1fb90bd9e49214358e474">rotate_left</a> (SharedNode rotation_root)</td></tr>
<tr class="memdesc:a67872d92abf1fb90bd9e49214358e474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a left rotation on the given node.  <a href="classavltree_1_1_a_v_l_tree_base.html#a67872d92abf1fb90bd9e49214358e474">More...</a><br /></td></tr>
<tr class="separator:a67872d92abf1fb90bd9e49214358e474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4975ea0011bf205f3007b1d6f4b018"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a8d4975ea0011bf205f3007b1d6f4b018">rotate_right</a> (SharedNode rotation_root)</td></tr>
<tr class="memdesc:a8d4975ea0011bf205f3007b1d6f4b018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a right rotation on the given node.  <a href="classavltree_1_1_a_v_l_tree_base.html#a8d4975ea0011bf205f3007b1d6f4b018">More...</a><br /></td></tr>
<tr class="separator:a8d4975ea0011bf205f3007b1d6f4b018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cf0ccf44b152cf43d81575ca860cd6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a80cf0ccf44b152cf43d81575ca860cd6">rebalance_node</a> (SharedNode node)</td></tr>
<tr class="memdesc:a80cf0ccf44b152cf43d81575ca860cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebalance the given node if its balance is greater than 1 or less than -1.  <a href="classavltree_1_1_a_v_l_tree_base.html#a80cf0ccf44b152cf43d81575ca860cd6">More...</a><br /></td></tr>
<tr class="separator:a80cf0ccf44b152cf43d81575ca860cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640bc236effbc90b828a4152c747c560"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a640bc236effbc90b828a4152c747c560">update_node</a> (SharedNode node)</td></tr>
<tr class="memdesc:a640bc236effbc90b828a4152c747c560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the given node after an insertion or deletion operation.  <a href="classavltree_1_1_a_v_l_tree_base.html#a640bc236effbc90b828a4152c747c560">More...</a><br /></td></tr>
<tr class="separator:a640bc236effbc90b828a4152c747c560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7a0b733c14ddf7a38b46b997e60b5c"><td class="memItemLeft" align="right" valign="top">virtual SharedNode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a0a7a0b733c14ddf7a38b46b997e60b5c">allocate_node</a> (const Value &amp;value)</td></tr>
<tr class="memdesc:a0a7a0b733c14ddf7a38b46b997e60b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new node object with the given value.  <a href="classavltree_1_1_a_v_l_tree_base.html#a0a7a0b733c14ddf7a38b46b997e60b5c">More...</a><br /></td></tr>
<tr class="separator:a0a7a0b733c14ddf7a38b46b997e60b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b376eb226dba3e8deb3ab021becedb"><td class="memItemLeft" align="right" valign="top">virtual SharedNode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a40b376eb226dba3e8deb3ab021becedb">copy_node</a> (ConstSharedNode node)</td></tr>
<tr class="memdesc:a40b376eb226dba3e8deb3ab021becedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the given node.  <a href="classavltree_1_1_a_v_l_tree_base.html#a40b376eb226dba3e8deb3ab021becedb">More...</a><br /></td></tr>
<tr class="separator:a40b376eb226dba3e8deb3ab021becedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac497a6a35ce91176e7f3cdc1767ff394"><td class="memItemLeft" align="right" valign="top">virtual SharedNode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#ac497a6a35ce91176e7f3cdc1767ff394">add_node</a> (const Value &amp;value)</td></tr>
<tr class="memdesc:ac497a6a35ce91176e7f3cdc1767ff394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new node to the tree.  <a href="classavltree_1_1_a_v_l_tree_base.html#ac497a6a35ce91176e7f3cdc1767ff394">More...</a><br /></td></tr>
<tr class="separator:ac497a6a35ce91176e7f3cdc1767ff394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c24c5d85978c917819f41b1c5698976"><td class="memItemLeft" align="right" valign="top">virtual SharedNode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a4c24c5d85978c917819f41b1c5698976">remove_node</a> (const Value &amp;value)</td></tr>
<tr class="memdesc:a4c24c5d85978c917819f41b1c5698976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a given node from the tree with the given value.  <a href="classavltree_1_1_a_v_l_tree_base.html#a4c24c5d85978c917819f41b1c5698976">More...</a><br /></td></tr>
<tr class="separator:a4c24c5d85978c917819f41b1c5698976"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aeff03bde490dac3141fbbeeee10e8160"><td class="memItemLeft" align="right" valign="top"><a id="aeff03bde490dac3141fbbeeee10e8160" name="aeff03bde490dac3141fbbeeee10e8160"></a>
SharedNode&#160;</td><td class="memItemRight" valign="bottom"><b>_root</b></td></tr>
<tr class="memdesc:aeff03bde490dac3141fbbeeee10e8160"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root of the tree. <br /></td></tr>
<tr class="separator:aeff03bde490dac3141fbbeeee10e8160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec14bbab6030f855b0b3a094ca016e08"><td class="memItemLeft" align="right" valign="top"><a id="aec14bbab6030f855b0b3a094ca016e08" name="aec14bbab6030f855b0b3a094ca016e08"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_size</b></td></tr>
<tr class="memdesc:aec14bbab6030f855b0b3a094ca016e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes in the tree. <br /></td></tr>
<tr class="separator:aec14bbab6030f855b0b3a094ca016e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key, typename Value, typename KeyOfValue, typename KeyCompare&gt;<br />
class avltree::AVLTreeBase&lt; Key, Value, KeyOfValue, KeyCompare &gt;</div><p >The base implementation of an AVL tree. </p>
<p ><b>NOTE</b>: For a basic AVL tree implementation, this interface is too complex. See the <a class="el" href="classavltree_1_1_a_v_l_tree.html" title="A simplified AVLTree interface.">AVLTree</a> class for a more basic interface to an AVL tree.</p>
<p >This is the base AVL tree implementation. Its template interface is designed in this way to handle mapping objects, and takes inspiration from libstdc++'s red-black tree interface for its implementation of a map. For implementing some tree-based objects that have a map-like design, this is the interface to use. Otherwise, the simplified versions of this interface, separated into <a class="el" href="classavltree_1_1_a_v_l_tree.html" title="A simplified AVLTree interface.">AVLTree</a> and <a class="el" href="classavltree_1_1_a_v_l_map.html" title="A mapping implementation based on an AVL tree.">AVLMap</a>, should suffice.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type class of the object that acts as the node's key, also known as its label. This value is the value responsible for indexing the nodes in the tree. This is expected to be a constant value&ndash; undefined behavior is likely to happen if you modify a tree node's key.</td></tr>
    <tr><td class="paramname">Value</td><td>The value type class of the object, which is expected to host the key value in some way, whose extraction of said key is determined by the functor KeyOfValue. This type can be the same as the key type with use of the <a class="el" href="structavltree_1_1_key_is_value.html" title="A functor for AVLTreeBase which treats the value argument as the key.">KeyIsValue</a> functor.</td></tr>
    <tr><td class="paramname">KeyOfValue</td><td>The functor which extracts the node's Key type value from the node's Value object. See <a class="el" href="structavltree_1_1_key_is_value.html" title="A functor for AVLTreeBase which treats the value argument as the key.">KeyIsValue</a> and <a class="el" href="structavltree_1_1_key_of_pair.html" title="A functor which treats the first value of a std::pair as its key.">KeyOfPair</a> for examples of how to use this value.</td></tr>
    <tr><td class="paramname">KeyCompare</td><td>The key comparison functor, usually std::less&lt;Key&gt;. This functor must conform to C++'s <a href="https://en.cppreference.com/w/cpp/named_req/Compare">Compare requirements</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac497a6a35ce91176e7f3cdc1767ff394" name="ac497a6a35ce91176e7f3cdc1767ff394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac497a6a35ce91176e7f3cdc1767ff394">&#9670;&#160;</a></span>add_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SharedNode <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::add_node </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new node to the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value the new node should have.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_key_exists.html" title="Exception thrown when the key already exists within the tree.">exception::KeyExists</a></td><td>Thrown when the key of the given value already exists within the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a7a0b733c14ddf7a38b46b997e60b5c" name="a0a7a0b733c14ddf7a38b46b997e60b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7a0b733c14ddf7a38b46b997e60b5c">&#9670;&#160;</a></span>allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SharedNode <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::allocate_node </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new node object with the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value the node should have. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0054359ae962c3551d17b5b2c799e10d" name="a0054359ae962c3551d17b5b2c799e10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0054359ae962c3551d17b5b2c799e10d">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">iterator</a> <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a default iterator to the beginning of the tree. </p>
<p >The default iterator is a post-order value iterator. </p>

</div>
</div>
<a id="a7e89d00f5b4a83f4e3fe5f0ca35499dd" name="a7e89d00f5b4a83f4e3fe5f0ca35499dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e89d00f5b4a83f4e3fe5f0ca35499dd">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_iterator</a> <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a default const iterator to the beginning of the tree. </p>
<p >The default iterator is a post-order value iterator. </p>

</div>
</div>
<a id="ae7feab33db9c3774e683f826c415b3d0" name="ae7feab33db9c3774e683f826c415b3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7feab33db9c3774e683f826c415b3d0">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1const__value__iterator.html">const_iterator</a> <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a default const iterator to the end of the tree. </p>
<p >The default iterator is a post-order value iterator. </p>

</div>
</div>
<a id="a4b7991228b296d8694d24c205debbfc4" name="a4b7991228b296d8694d24c205debbfc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7991228b296d8694d24c205debbfc4">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the given key exists in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the key was found, false otherwise. </dd></dl>

</div>
</div>
<a id="ab33e8ed78f5a990e73a4896446d9992b" name="ab33e8ed78f5a990e73a4896446d9992b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33e8ed78f5a990e73a4896446d9992b">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the given tree into this tree. </p>
<p >This will destroy the current tree if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other tree to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40b376eb226dba3e8deb3ab021becedb" name="a40b376eb226dba3e8deb3ab021becedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b376eb226dba3e8deb3ab021becedb">&#9670;&#160;</a></span>copy_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SharedNode <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::copy_node </td>
          <td>(</td>
          <td class="paramtype">ConstSharedNode&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>node to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7795faf04ec3b8187b5e5f05013b6e1e" name="a7795faf04ec3b8187b5e5f05013b6e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7795faf04ec3b8187b5e5f05013b6e1e">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classavltree_1_1_a_v_l_tree_base_1_1value__iterator.html">iterator</a> <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a default iterator to the end of the tree. </p>
<p >The default iterator is a post-order value iterator. </p>

</div>
</div>
<a id="a1aa48749a74d07d1b9bd5aca39a7371a" name="a1aa48749a74d07d1b9bd5aca39a7371a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa48749a74d07d1b9bd5aca39a7371a">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; SharedNode &gt; <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to find the node corresponding to the given key in this tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node with the given key, or std::nullopt if no node was found. </dd></dl>

</div>
</div>
<a id="a213781a9c66c415c28de0509259c533d" name="a213781a9c66c415c28de0509259c533d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213781a9c66c415c28de0509259c533d">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; ConstSharedNode &gt; <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to find the const node corresponding to the given key in this tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node with the given key, or std::nullopt if no node was found. </dd></dl>

</div>
</div>
<a id="a26e5c416fe580918417ccdbc54754c4a" name="a26e5c416fe580918417ccdbc54754c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e5c416fe580918417ccdbc54754c4a">&#9670;&#160;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SharedNode <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to get the node with the given key in the tree, throwing an exception if it fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node corresponding to the given key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_key_not_found.html" title="Exception thrown when the key is not found in the tree.">exception::KeyNotFound</a></td><td>Thrown if the key is not found in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae29f033cf7fa7a6737a3728bec50aab9" name="ae29f033cf7fa7a6737a3728bec50aab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29f033cf7fa7a6737a3728bec50aab9">&#9670;&#160;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstSharedNode <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to get the const node with the given key in the tree, throwing an exception if it fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node corresponding to the given key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_key_not_found.html" title="Exception thrown when the key is not found in the tree.">exception::KeyNotFound</a></td><td>Thrown if the key is not found in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a967cd2e0fe0dfe8b9edfff94d69697e7" name="a967cd2e0fe0dfe8b9edfff94d69697e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967cd2e0fe0dfe8b9edfff94d69697e7">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SharedNode <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the given value into the tree. </p>
<p >See <a class="el" href="classavltree_1_1_a_v_l_tree_base.html#ac497a6a35ce91176e7f3cdc1767ff394" title="Add a new node to the tree.">AVLTreeBase::add_node</a>. </p>

</div>
</div>
<a id="a2c2d89eb2a723c38c7ff3c615eb57aae" name="a2c2d89eb2a723c38c7ff3c615eb57aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2d89eb2a723c38c7ff3c615eb57aae">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the tree is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the tree is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a80cf0ccf44b152cf43d81575ca860cd6" name="a80cf0ccf44b152cf43d81575ca860cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cf0ccf44b152cf43d81575ca860cd6">&#9670;&#160;</a></span>rebalance_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::rebalance_node </td>
          <td>(</td>
          <td class="paramtype">SharedNode&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rebalance the given node if its balance is greater than 1 or less than -1. </p>
<p >When a node needs to be rebalanced, certain rotation operations need to happen. See <a href="https://en.wikipedia.org/wiki/AVL_tree#Rebalancing">the rebalancing section</a> on AVL trees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to rebalance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_null_pointer.html" title="Exception thrown when encountering an unexpected null pointer.">exception::NullPointer</a></td><td>Thrown when the node argument is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ccf63f9f9fd8b3e77644eac25378428" name="a8ccf63f9f9fd8b3e77644eac25378428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccf63f9f9fd8b3e77644eac25378428">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node with the given key from the tree. </p>
<p >See <a class="el" href="classavltree_1_1_a_v_l_tree_base.html#a4c24c5d85978c917819f41b1c5698976" title="Remove a given node from the tree with the given value.">AVLTreeBase::remove_node</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to remove from the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_key_not_found.html" title="Exception thrown when the key is not found in the tree.">exception::KeyNotFound</a></td><td>Thrown if the key isn't found in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c24c5d85978c917819f41b1c5698976" name="a4c24c5d85978c917819f41b1c5698976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c24c5d85978c917819f41b1c5698976">&#9670;&#160;</a></span>remove_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SharedNode <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::remove_node </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a given node from the tree with the given value. </p>
<p >Note that only the key of the value is used to verify the node to delete, not the whole value itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value object to remove from the tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_empty_tree.html" title="Exception thrown when the tree contains no nodes.">exception::EmptyTree</a></td><td>Thrown when the tree is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_node_not_found.html" title="Exception thrown when the node being searched wasn&#39;t found.">exception::NodeNotFound</a></td><td>Thrown when the key of the value is not found within the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67872d92abf1fb90bd9e49214358e474" name="a67872d92abf1fb90bd9e49214358e474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67872d92abf1fb90bd9e49214358e474">&#9670;&#160;</a></span>rotate_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::rotate_left </td>
          <td>(</td>
          <td class="paramtype">SharedNode&#160;</td>
          <td class="paramname"><em>rotation_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a left rotation on the given node. </p>
<p >See <a href="https://en.wikipedia.org/wiki/AVL_tree#Rebalancing">the rebalancing section</a> for an AVL tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation_root</td><td>The node to rotate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_null_pointer.html" title="Exception thrown when encountering an unexpected null pointer.">exception::NullPointer</a></td><td>Thrown when the rotation root is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d4975ea0011bf205f3007b1d6f4b018" name="a8d4975ea0011bf205f3007b1d6f4b018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4975ea0011bf205f3007b1d6f4b018">&#9670;&#160;</a></span>rotate_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::rotate_right </td>
          <td>(</td>
          <td class="paramtype">SharedNode&#160;</td>
          <td class="paramname"><em>rotation_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a right rotation on the given node. </p>
<p >See <a href="https://en.wikipedia.org/wiki/AVL_tree#Rebalancing">the rebalancing section</a> for an AVL tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation_root</td><td>The node to rotate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_null_pointer.html" title="Exception thrown when encountering an unexpected null pointer.">exception::NullPointer</a></td><td>Thrown when the rotation root is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42a4af9ed9fe2b84b4dfa20dbd9eb72f" name="a42a4af9ed9fe2b84b4dfa20dbd9eb72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a4af9ed9fe2b84b4dfa20dbd9eb72f">&#9670;&#160;</a></span>search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; SharedNode, int &gt; &gt; <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::search </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search the tree for the given key. </p>
<p >This function does a basic binary traversal on the tree for the given key, with the ability to return the path taken in order to find that key&ndash; or to not find that key. It will immediately terminate when it finds the given key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs: the node that was traversed, and the number representing the path which was taken. 1 means right, -1 means left, 0 means it matched the key. </dd></dl>

</div>
</div>
<a id="a4282cd8896a0f9aaa3cc125062255494" name="a4282cd8896a0f9aaa3cc125062255494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4282cd8896a0f9aaa3cc125062255494">&#9670;&#160;</a></span>search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; ConstSharedNode, int &gt; &gt; <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::search </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search the tree for the given key, returning const nodes. </p>
<p >This function does a basic binary traversal on the tree for the given key, with the ability to return the path taken in order to find that key&ndash; or to not find that key. It will immediately terminate when it finds the given key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs: the node that was traversed, and the number representing the path which was taken. 1 means right, -1 means left, 0 means it matched the key. </dd></dl>

</div>
</div>
<a id="a13f807cea16eccdc3351e0681b8ecd37" name="a13f807cea16eccdc3351e0681b8ecd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f807cea16eccdc3351e0681b8ecd37">&#9670;&#160;</a></span>set_left_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::set_left_child </td>
          <td>(</td>
          <td class="paramtype">SharedNode&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SharedNode&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the left child of the given node. </p>
<p >This sets the <em>target</em> as the parent of <em>child</em> and the <em>child</em> as the left-child of <em>target</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The node to set the left child of. </td></tr>
    <tr><td class="paramname">child</td><td>The child node to set in the target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_null_pointer.html" title="Exception thrown when encountering an unexpected null pointer.">exception::NullPointer</a></td><td>Thrown when the target argument is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acabaa07e25f87d547a0fb3837487ac52" name="acabaa07e25f87d547a0fb3837487ac52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabaa07e25f87d547a0fb3837487ac52">&#9670;&#160;</a></span>set_parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::set_parent </td>
          <td>(</td>
          <td class="paramtype">SharedNode&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SharedNode&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the parent of the given node. </p>
<p >This sets the <em>parent</em> of the <em>target</em> node and sets the <em>target</em> as the left or right child of the <em>parent</em>, depending on how it compares with the node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target node whose parent you wish to alter. </td></tr>
    <tr><td class="paramname">parent</td><td>The parent node to change to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_null_pointer.html" title="Exception thrown when encountering an unexpected null pointer.">exception::NullPointer</a></td><td>Thrown when the target argument is null. </td></tr>
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_node_keys_match.html" title="Exception thrown when the keys of two nodes match when they shouldn&#39;t.">exception::NodeKeysMatch</a></td><td>Thrown when the target key is equal to the parent key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69c625f8cea8607f7638789f0273b8b2" name="a69c625f8cea8607f7638789f0273b8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c625f8cea8607f7638789f0273b8b2">&#9670;&#160;</a></span>set_right_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::set_right_child </td>
          <td>(</td>
          <td class="paramtype">SharedNode&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SharedNode&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the right child of the given node. </p>
<p >This sets the <em>target</em> as the parent of <em>child</em> and the <em>child</em> as the right-child of <em>target</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The node to set the right child of. </td></tr>
    <tr><td class="paramname">child</td><td>The child node to set in the target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_null_pointer.html" title="Exception thrown when encountering an unexpected null pointer.">exception::NullPointer</a></td><td>Thrown when the target argument is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a562a02962c9d2dee95b058bfa1f33bab" name="a562a02962c9d2dee95b058bfa1f33bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562a02962c9d2dee95b058bfa1f33bab">&#9670;&#160;</a></span>to_vec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Value &gt; <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::to_vec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert this tree into a vector. </p>
<p >Performs a post-order traversal on the tree and gets const values from the nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of values in the tree. </dd></dl>

</div>
</div>
<a id="a640bc236effbc90b828a4152c747c560" name="a640bc236effbc90b828a4152c747c560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640bc236effbc90b828a4152c747c560">&#9670;&#160;</a></span>update_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename KeyOfValue , typename KeyCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classavltree_1_1_a_v_l_tree_base.html">avltree::AVLTreeBase</a>&lt; Key, Value, KeyOfValue, KeyCompare &gt;::update_node </td>
          <td>(</td>
          <td class="paramtype">SharedNode&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the given node after an insertion or deletion operation. </p>
<p >This function simply updates the height and verifies the tree is balanced, but is virtual for tree objects which need to update more information or perform other actions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classavltree_1_1exception_1_1_null_pointer.html" title="Exception thrown when encountering an unexpected null pointer.">exception::NullPointer</a></td><td>Thrown when the node argument is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="avltree_8hpp_source.html">avltree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
